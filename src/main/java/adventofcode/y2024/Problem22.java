package adventofcode.y2024;

import adventofcode.commons.AoCInput;
import adventofcode.commons.AoCProblem;
import adventofcode.commons.ArrayKey;

import java.util.*;

/**
 * Day 22: Monkey Market
 * https://adventofcode.com/2024/day/22
 */
public class Problem22 extends AoCProblem<Long> {

    public static void main(String[] args) throws Exception {
        Problem22 p = new Problem22();
        p.loadResourceAndSolve(false);
    }

    public static final int SEQUENCE_LENGTH = 2000;

    List<Long> seeds;

    @Override
    public void processInput(AoCInput input) throws Exception {
        seeds = input.toList().stream()
                     .map(Long::parseLong)
                     .toList();
    }

    /**
     * ...For each buyer, simulate the creation of 2000 new secret numbers.
     * What is the sum of the 2000th secret number generated by each buyer?
     */
    @Override
    public Long solvePartOne() throws Exception {
        long result = 0;
        for (Long n : seeds) {
            for (int i = 0; i < SEQUENCE_LENGTH; ++i) n = generateNumber(n);
            result += n;
        }
        return result;
    }

    private long generateNumber(long n) {
        n = (n * 64) ^ n; // 1st step
        n = n % 16777216; // prune
        n = (n / 32) ^ n; // 2nd step and round down
        n = n % 16777216; // prune
        n = (n * 2048) ^ n; // 3rd step
        n = n % 16777216; // prune
        return n;
    }

    /**
     * ...Figure out the best sequence to tell the monkey so that by looking
     * for that same sequence of changes in every buyer's future prices,
     * you get the most bananas in total.
     * What is the most bananas you can get?
     */
    @Override
    public Long solvePartTwo() throws Exception {
        List<Buyer> buyers = new ArrayList<>();
        for (long n : seeds) {
            buyers.add(buildBuyer(n));
        }
        return searchBestSequenceScore(buyers);
    }

    private long searchBestSequenceScore(List<Buyer> buyers) {
        Set<ArrayKey> visited = new HashSet<>();

        long maxBananas = buyers.stream().mapToLong(Buyer::bestBuy).sum();
        long bestBananas = 0;

        for (Buyer buyer : buyers) {
            for (Buy buy : buyer.bestBuys) {
                if (visited.contains(buy.key)) continue;
                visited.add(buy.key);
                long bananas = buyBananas(buy.key, buyers, bestBananas, maxBananas);
                if (bananas > bestBananas)
                    bestBananas = bananas;
            }
        }

        return bestBananas;
    }

    private long buyBananas(ArrayKey seq, List<Buyer> buyers, long bestBananas, long maxBananas) {
        long bananas = 0;
        for (Buyer buyer : buyers) {
            if (maxBananas + bananas < bestBananas) return 0L;
            bananas += buyer.sequenceMap.getOrDefault(seq, 0L);
            maxBananas -= buyer.bestBuy;
        }
        return bananas;
    }

    record Buy(ArrayKey key, long price) {}

    record Buyer(Map<ArrayKey, Long> sequenceMap, List<Buy> bestBuys, long bestBuy) {}

    private Buyer buildBuyer(long n) {
        // build sequence map
        Map<ArrayKey, Long> sequenceMap = new HashMap<>();
        ArrayDeque<Long> sequence = new ArrayDeque<>();
        Sell s = new Sell(n, n % 10L, null);
        sequence.add(0L); // add first null to simplify cut later
        for (int i = 0; i < SEQUENCE_LENGTH; ++i) {
            s = generateSell(s);
            sequence.add(s.diff);
            if (sequence.size() > 4) {
                sequence.removeFirst();
                if (s.price == 0) continue;
                ArrayKey key = ArrayKey.toKey(sequence.toArray());
                // take first sequence!
                // the monkey buys at first sequence seen,
                // not after the best sequence in the entire set
                if (sequenceMap.containsKey(key)) continue;
                sequenceMap.put(key, s.price);
            }
        }

        // sort buys by best price
        List<Buy> buys = new ArrayList<>(sequenceMap.size());
        for (var e : sequenceMap.entrySet()) {
            Buy buy = new Buy(e.getKey(), e.getValue());
            buys.add(buy);
        }
        buys.sort((a, b) -> Long.compare(b.price, a.price));

        //
        return new Buyer(sequenceMap, buys, buys.get(0).price);
    }

    record Sell(long n, long price, Long diff) {}

    private Sell generateSell(Sell prev) {
        long n1 = generateNumber(prev.n);
        long price = n1 % 10L;
        long diff = price - prev.price;
        return new Sell(n1, price, diff);
    }
}
