package adventofcode.y2024;

import adventofcode.commons.AoCInput;
import adventofcode.commons.AoCProblem;
import adventofcode.commons.ArrayKey;

import java.util.*;

/**
 * Day 22: Monkey Market
 * https://adventofcode.com/2024/day/22
 */
public class Problem22v2 extends AoCProblem<Long, Problem22v2> {

    public static void main(String[] args) throws Exception {
        Problem22v2 p = new Problem22v2();
        p.loadResourceAndSolve(false);
    }

    public static final int NUMBERS_TO_GENERATE = 2000;

    List<Long> seeds;

    @Override
    public void processInput(AoCInput input) throws Exception {
        seeds = input.toList().stream()
                     .map(Long::parseLong)
                     .toList();
    }

    /**
     * ...For each buyer, simulate the creation of 2000 new secret numbers.
     * What is the sum of the 2000th secret number generated by each buyer?
     */
    @Override
    public Long solvePartOne() throws Exception {
        long result = 0;
        for (Long n : seeds) {
            for (int i = 0; i < NUMBERS_TO_GENERATE; ++i) n = generateNumber(n);
            result += n;
        }
        return result;
    }

    private long generateNumber(long n) {
        n = (n * 64) ^ n; // 1st step
        n = n % 16777216; // prune
        n = (n / 32) ^ n; // 2nd step and round down
        n = n % 16777216; // prune
        n = (n * 2048) ^ n; // 3rd step
        n = n % 16777216; // prune
        return n;
    }

    /**
     * ...Figure out the best sequence to tell the monkey so that by looking
     * for that same sequence of changes in every buyer's future prices,
     * you get the most bananas in total.
     * What is the most bananas you can get?
     */
    @Override
    public Long solvePartTwo() throws Exception {
        Map<ArrayKey, Long> bestBuys = new HashMap<>();
        for (long n : seeds) {
            collectBestBuys(n, bestBuys);
        }
        return bestBuys.values().stream()
                       .mapToLong(Long::longValue)
                       .max().getAsLong();
    }

    private void collectBestBuys(long n, Map<ArrayKey, Long> bestBuys) {
        Set<ArrayKey> visited = new HashSet<>();
        ArrayDeque<Long> diffs = new ArrayDeque<>();
        diffs.add(0L); // fill first item to easily cut the ArrayDeque when > 5
        long lastPrice = n % 10L;
        for (int i = 0; i < NUMBERS_TO_GENERATE; ++i) {
            n = generateNumber(n);
            long price = n % 10L;
            long diff = price - lastPrice;
            lastPrice = price;
            diffs.add(diff);
            if (diffs.size() > 4) {
                diffs.removeFirst();
                ArrayKey key = ArrayKey.toKey(diffs.toArray());
                if (!visited.add(key)) continue;
                bestBuys.compute(key, (k, v) -> v == null ? price : v + price);
            }
        }
    }
}
